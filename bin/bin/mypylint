#!/usr/bin/env python3

"""A script that combines multiple Python linters and checkers."""

import re
import subprocess
import sys
from argparse import ArgumentParser
from collections import namedtuple
from os import environ, execv
from pathlib import Path
from typing import List

VENV_PYTHON = Path(environ['PYTHON_VENV_HOME'], 'mypylint', 'bin', 'python3').expanduser()

Error = namedtuple('Error', 'filename, linenum, column, message')


def run_pylint(path):
    # type: (Path) -> List[Error]
    """Get errors from pylint.

    Parameters:
        path (Path): The path to the file to check.

    Returns:
        List[Error]: A list of errors.
    """
    process = subprocess.run(
        [
            VENV_PYTHON,
            '-m',
            'pylint',
            str(path),
            '--msg-template',
            '{filename}:{linenum}:{column}: {msg} [{msg_id} {symbol}]',
        ],
        check=False,
        capture_output=True,
    )
    errors = []
    for line in process.stdout.decode('utf-8').splitlines():
        match = re.fullmatch(
            ' '.join([
                '(?P<filename>[^:]*):(?P<linenum>[0-9]+):(?P<column>-?[0-9]+):',
                '(?P<message>.*) \[(?P<message_id>.*)\]',
            ]),
            line.strip(),
        )
        if not match:
            continue
        filename = match.group('filename')
        linenum = match.group('linenum')
        column = match.group('column')
        message = match.group('message')
        message_id = match.group('message_id')
        errors.append(Error(filename, int(linenum), int(column), f'{message} ({message_id})'))
    return errors


def run_pydocstyle(path):
    # type: (Path) -> List[Error]
    """Get errors from pydocstyle.

    Parameters:
        path (Path): The path to the file to check.

    Returns:
        List[Error]: A list of errors.
    """
    process = subprocess.run(
        [
            VENV_PYTHON,
            '-m',
            'pydocstyle',
            str(path),
        ],
        check=False,
        capture_output=True,
    )
    lines = process.stdout.decode('utf-8').splitlines()
    errors = []
    for line1, line2 in zip(lines[0::2], lines[1::2]):
        match1 = re.fullmatch('(?P<filename>[^:]*):(?P<linenum>[0-9]+) .*', line1.strip())
        match2 = re.fullmatch('^(?P<message_id>[^:]*): (?P<message>.*)', line2.strip())
        if match1 is None or match2 is None:
            continue
        filename = match1.group('filename')
        linenum = match1.group('linenum')
        column = 0
        message = match2.group('message')
        message_id = match2.group('message_id')
        errors.append(Error(filename, int(linenum), int(column), f'{message} ({message_id})'))
    return errors


def run_mypy(path):
    # type: (Path) -> List[Error]
    """Get errors from mypy.

    Parameters:
        path (Path): The path to the file to check.

    Returns:
        List[Error]: A list of errors.
    """
    process = subprocess.run(
        [
            VENV_PYTHON,
            '-m',
            'mypy',
            '--strict',
            '--ignore-missing-imports',
            '--no-warn-return-any',
            '--show-column-numbers',
            '--show-error-codes',
            str(path),
        ],
        check=False,
        capture_output=True,
    )
    errors = []
    for line in process.stdout.decode('utf-8').splitlines():
        match = re.fullmatch(
            ' '.join([
                '(?P<filename>[^:]*):(?P<linenum>[0-9]+):(?P<column>[0-9]+):',
                '(?P<output_type>[^:]*):',
                '(?P<message>.*?) *\[(?P<message_id>.*)\]',
            ]),
            line.strip(),
        )
        if not match:
            continue
        filename = match.group('filename')
        linenum = match.group('linenum')
        column = match.group('column')
        output_type = match.group('output_type')
        message = match.group('message')
        message_id = match.group('message_id')
        if output_type != 'error':
            continue
        errors.append(Error(filename, int(linenum), int(column), f'{message} ({message_id})'))
    return errors


def main():
    # type: () -> None
    """Deal with command line arguments."""
    has_errors = False
    for arg in sys.argv[1:]:
        errors = []
        errors.extend(run_pylint(Path(arg)))
        errors.extend(run_pydocstyle(Path(arg)))
        errors.extend(run_mypy(Path(arg)))
        for error in sorted(errors):
            print(f'{error.filename}:{error.linenum}:{error.column}: {error.message}', file=sys.stderr)
        has_errors |= bool(errors)
    if has_errors:
        sys.exit(1)
    sys.exit(0)
    

if __name__ == '__main__':
    main()
