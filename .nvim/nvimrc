set nocompatible

" FIXME temporarily disabled until neovim issue #1508 is fixed
"let python_host_prog = "python3"

" vim-plug plug-in manager
let s:found_plugins = isdirectory(expand('~/.nvim/bundle'))
if s:found_plugins
	call plug#begin('~/.nvim/bundle')
	Plug 'kien/ctrlp.vim'
	Plug 'hdima/python-syntax', {'for': 'python'}
	Plug 'johnsyweb/vim-makeshift'
	Plug 'justinnhli/journal.vim', {'for': 'journal'}
	Plug 'rhysd/clever-f.vim'
	Plug 'tomasr/molokai'
	Plug 'tpope/vim-fugitive'
	Plug 'tpope/vim-sleuth'
	call plug#end()
endif

" use additional runtime directories when available: local neovim clone, Arch neovim install, Mac neovim install, Arch vim install, MacVim install
let vim_runtimes = [expand('~/neovim/runtime'), '/usr/share/nvim/runtime', '/usr/local/share/nvim/runtime', '/usr/share/vim/vim74', '/Applications/MacVim.app/Contents/Resources/vim/runtime']
for runtime in vim_runtimes
	if isdirectory(runtime)
		let &runtimepath = &runtimepath.','.runtime
	endif
endfor

" functional functions {
	function! UnicodeToAscii()
		%s/[′‘’]/'/eg
		%s/’’/"/eg
		%s/‘‘/"/eg
		%s/[“”]/"/eg
		%s/…/.../eg
		%s/[–—―]/ - /eg
		%s/ / /eg " U+200A (hair space)
	endfunction

	function! s:CloseRightTabs()
		let cur=tabpagenr()
		while cur < tabpagenr('$')
			exe 'tabclose' . ' ' . (cur + 1)
		endwhile
	endfunction

	function! s:MoveToRelTab(n)
		let l:num_tabs = tabpagenr("$")
		let l:cur_tab = tabpagenr()
		let l:cur_win = winnr('#')
		let l:cur_buf = bufnr('%')
		let l:new_tab = a:n + l:cur_tab
		if a:n == 0 || (l:num_tabs == 1 && winnr("$") == 1)
			return
		endif
		if l:new_tab < 1
			exec "0tabnew"
			let l:cur_tab += 1
		elseif l:new_tab > l:num_tabs
			exec "tablast"
			exec "tabnew"
		else
			if a:n < 0
				if l:num_tabs == tabpagenr('$')
					exec "tabprev ".abs(a:n)
				elseif a:n != -1
					exec "tabprev ".(abs(a:n)-1)
				endif
			else
				if l:num_tabs == tabpagenr('$')
					exec "tabnext ".l:new_tab
				elseif a:n != 1
					exec "tabnext ".(l:new_tab-1)
				endif
			endif
			vert botright split
		endif
		exec "b".l:cur_buf
		let l:new_tab = tabpagenr()
		exec "tabnext".l:cur_tab
		exec l:cur_win."wincmd c"
		if l:new_tab > l:num_tabs
			exec "tabnext".(l:new_tab-1)
		else
			exec "tabnext".l:new_tab
		endif
		" FIXME fails when new_tab is the highest tab
	endfunction

	function! s:IndentTextObject(updown, inout, visual)
		if a:visual
			normal!gv
		endif
		let line_num = line(".")
		let step = (a:updown > 0 ? 1 : -1)
		let src_indent = indent(line_num)
		let dest_indent = src_indent + (a:inout * &tabstop)
		if dest_indent < 0
			let dest_indent = 0
		endif
		let cur_indent = indent(line_num)
		let line_num += step
		while 1 <= line_num && line_num <= line("$")
			let cur_indent = indent(line_num)
			if cur_indent < src_indent || cur_indent == dest_indent
				if a:visual && step == 1
					let line_num -= 1
				end
				call cursor(line_num, 0)
				return
			endif
			let line_num += step
		endwhile
	endfunction
" }

" setting functions {
	function! MyTabLine()
		let s = ''
		let t = tabpagenr()
		for i in range(tabpagenr('$'))
			let buflist = tabpagebuflist(i+1)
			let winnr = tabpagewinnr(i+1)
			let bufnr = buflist[winnr - 1]
			let file = bufname(bufnr)
			" set highlighting
			let s .= (i+1 == t ? '%#TabLineSel#' : '%#TabLine#')
			let s .= ' '
			" set filename
			if file == ''
				let s .= '[No Name]'
			else
				let s .= fnamemodify(file, ':p:t')
			endif
			" set window number and modified flag
			let s .= ' ['
			let s .= tabpagewinnr(i+1,'$')
			for b in buflist
				if getbufvar(b, "&modified" )
					let s .= '+'
					break
				endif
			endfor
			let s .= '] '
		endfor
		let s .= '%T%#TabLineFill#%='
		return s
	endfunction
" }

" sessions {
	set   history=250
	if filereadable(expand("~/.nvim/viminfo"))
		set   viminfo='50,<100,h,n~/.nvim/viminfo
	else
		set   viminfo='50,<100,h,n~/.viminfo
	endif
	if has("persistent_undo")
		set   undofile
	endif
" }

" vim GUI {
	set   confirm
	set   display=lastline,uhex
	set noerrorbells
	set guioptions-=T
	set guioptions-=L
	set guioptions-=r
	set   laststatus=2
	set   lazyredraw
	if has("linebreak")
		set   linebreak
	endif
	let   netrw_liststyle=3
	set   number
	if has("cmdline_info")
		set   showcmd
	endif
	if has("windows")
		set   splitbelow
	endif
	if has("vertsplit")
		set   splitright
	endif
	if has("statusline")
		set   statusline=%n\ %f%(\ %M%)\ [%{&ff}]%r%y%#warningmsg#%{&paste?'[paste]':''}%*%=%<%1.30{getcwd()}\ (%l/%L,%c)%4P
	endif
	if has("windows")
		set showtabline=2
		set tabline=%!MyTabLine()
	endif
	set   title
	if has('gui_running')
		set   visualbell
	else
		set novisualbell
	endif
	if has("wildmenu")
		set   wildmode=longest,list
		set   wildignore+=*.pyc
	endif
	set nowrap
	let g:netrw_winsize=50
" }

" settings {
	filetype plugin on
	filetype indent on
	set   autoindent
	set   autoread
	if has("multi_byte")
		set nobomb
	endif
	set   backspace=indent,eol,start
	if has("linebreak") && v:version > 703
		set   breakindent
		set   breakindentopt=shift:1
	endif
	if has("insert_expand")
		set   completeopt=longest,menu
	endif
	if has("multi_byte")
		set   encoding=utf-8
	endif
	set noesckeys
	if has("multi_byte")
		set   fileencoding=utf-8
	endif
	if has("folding")
		set   foldclose=all
		set nofoldenable
		set   foldmethod=syntax
		set   foldminlines=0
	endif
	if has("extra_search")
		set   hlsearch
	endif
	set   ignorecase
	if has("insert_expand")
		set noinfercase
	endif
	if has("extra_search")
		set   incsearch
	endif
	set   scrolloff=1
	set   shiftwidth=4
	set   sidescroll=1
	set   sidescrolloff=10
	set   smartcase
	if has("syntax")
		set   spell
		set   spellcapcheck=
	endif
	set nostartofline
	set   tabstop=4
	set   whichwrap=b,s,<,>,h,l,[,]
" }

" highlighting and color {
	set t_Co=256
	if has("syntax")
		syntax enable
	endif
	set background=dark
	if s:found_plugins
		colorscheme molokai
	else
		colorscheme default
	endif
	highlight clear MatchParen
	highlight link MatchParen DiffAdd
	highlight clear Visual
	highlight link Visual StatusLine
" }

" key mappings {
	mapclear
	mapclear!
	let mapleader = ' '

	" disable the default leader
	nnoremap \ <nop>
	
	" text movement {
		" remove all uses of arrow keys
		noremap   <up>       <nop>
		noremap   <down>     <nop>
		noremap   <left>     <nop>
		noremap   <right>    <nop>
		noremap   <C-up>     <nop>
		noremap   <C-down>   <nop>
		noremap   <C-left>   <nop>
		noremap   <C-right>  <nop>
		noremap   <S-up>     <nop>
		noremap   <S-down>   <nop>
		noremap   <S-left>   <nop>
		noremap   <S-right>  <nop>
		inoremap  <up>       <nop>
		inoremap  <down>     <nop>
		inoremap  <left>     <nop>
		inoremap  <right>    <nop>
		inoremap  <C-up>     <nop>
		inoremap  <C-down>   <nop>
		inoremap  <C-left>   <nop>
		inoremap  <C-right>  <nop>
		inoremap  <S-up>     <nop>
		inoremap  <S-down>   <nop>
		inoremap  <S-left>   <nop>
		inoremap  <S-right>  <nop>

		" bash/emacs home/end commands
		nnoremap  <C-a>  ^
		nnoremap  <C-e>  $
		cnoremap  <C-a>  <Home>
		cnoremap  <C-e>  <End>
		inoremap  <C-a>  <Home>
		inoremap  <C-e>  <End>
		vnoremap  <C-a>  <Home>
		vnoremap  <C-e>  <End>

		" jump to previous/next line with less/same/more indentation
		nnoremap <silent> [, :<C-u>call <SID>IndentTextObject(-1, -1, 0)<cr>
		nnoremap <silent> [. :<C-u>call <SID>IndentTextObject(-1, 0, 0)<cr>
		nnoremap <silent> [/ :<C-u>call <SID>IndentTextObject(-1, 1, 0)<cr>
		nnoremap <silent> ], :<C-u>call <SID>IndentTextObject(1, -1, 0)<cr>
		nnoremap <silent> ]. :<C-u>call <SID>IndentTextObject(1, 0, 0)<cr>
		nnoremap <silent> ]/ :<C-u>call <SID>IndentTextObject(1, 1, 0)<cr>
		onoremap <silent> [, :<C-u>call <SID>IndentTextObject(-1, -1, 0)<cr>
		onoremap <silent> [. :<C-u>call <SID>IndentTextObject(-1, 0, 0)<cr>
		onoremap <silent> [/ :<C-u>call <SID>IndentTextObject(-1, 1, 0)<cr>
		onoremap <silent> ], :<C-u>call <SID>IndentTextObject(1, -1, 0)<cr>
		onoremap <silent> ]. :<C-u>call <SID>IndentTextObject(1, 0, 0)<cr>
		onoremap <silent> ]/ :<C-u>call <SID>IndentTextObject(1, 1, 0)<cr>
		vnoremap <silent> [, <esc>:call <SID>IndentTextObject(-1, -1, 1)<cr><esc>gv
		vnoremap <silent> [. <esc>:call <SID>IndentTextObject(-1, 0, 1)<cr><esc>gv
		vnoremap <silent> [/ <esc>:call <SID>IndentTextObject(-1, 1, 1)<cr><esc>gv
		vnoremap <silent> ], <esc>:call <SID>IndentTextObject(1, -1, 1)<cr><esc>gv
		vnoremap <silent> ]. <esc>:call <SID>IndentTextObject(1, 0, 1)<cr><esc>gv
		vnoremap <silent> ]/ <esc>:call <SID>IndentTextObject(1, 0, 1)<cr><esc>gv
	" }

	" window/tab management {
		" <leader>t mappings for opening and closing tabs
		nnoremap  <leader>tn  :tabnew 
		nnoremap  <leader>th  :tabmove -1<cr>
		nnoremap  <leader>tl  :tabmove +1<cr>
		nnoremap  <leader>to  :tabonly<cr>
		nnoremap  <leader>tp  :call <SID>CloseRightTabs()<cr>
		nnoremap  <leader>tc  :tabclose<cr>

		" <leader>w mappings for opening and closing windows
		nnoremap  <leader>wh   :leftabove vsplit 
		nnoremap  <leader>wj   :rightbelow split 
		nnoremap  <leader>wk   :leftabove split 
		nnoremap  <leader>wl   :rightbelow vsplit 
		nnoremap  <leader>wnh  :leftabove vnew<cr>
		nnoremap  <leader>wnj  :rightbelow new<cr>
		nnoremap  <leader>wnk  :leftabove new<cr>
		nnoremap  <leader>wnl  :rightbelow vnew<cr>
		nnoremap  <leader>wo   :only<cr>
		nnoremap  <leader>wc   :close<cr>

		" Shift+HL for moving between tabs
		noremap  <S-l>  :tabnext<cr>
		noremap  <S-h>  :tabprev<cr>

		" Ctrl+HJKL for moving between windows
		noremap  <C-j>  <C-w>j
		noremap  <C-k>  <C-w>k
		noremap  <C-h>  <C-w>h
		noremap  <C-l>  <C-w>l
	" }

	" disable annoying features {
		" disable Shift+JK in visual mode
		vnoremap  <S-j>  <nop>
		vnoremap  <S-k>  <nop>

		" disable the manpage lookup
		vnoremap  K  <Nop>

		" disable Ex mode
		nnoremap  Q  <Nop>
	" }

	" search, command line, and quick fix {
		" default to very magic search
		nnoremap  /  /\v
		nnoremap  ?  ?\v

		" easily search for selected text
		vnoremap  /  y<Esc>/\V<C-r>"<cr>
		vnoremap  ?  y<Esc>?\V<C-r>"<cr>

		" rebind n/N to always go forwards/backwards (and turns on highlighting)
		nnoremap  n       :set hlsearch<cr>/<cr>zz
		nnoremap  <S-n>   :set hlsearch<cr>?<cr>zz
		vnoremap  n       :set hlsearch<cr>/<cr>zz
		vnoremap  <S-n>   :set hlsearch<cr>?<cr>zz

		" force the use of the command line window
		nnoremap  :  :<C-f>i
		nnoremap  q: :
		vnoremap  :  :<C-f>i
		vnoremap  q: :

		" Shift+JK for moving between quickfixes
		nnoremap  <S-j>  :lnext<cr>
		nnoremap  <S-k>  :lprevious<cr>
	" }

	" editing {
		" stay in visual mode after tabbing
		vnoremap  <tab>    >gv
		vnoremap  <S-tab>  <gv
		vnoremap  >        >gv
		vnoremap  <        <gv

		" jump to the end of pasted text
		nnoremap <silent> p p`]

		" Make Y behave like other capitals
		nnoremap Y y$
	" }

	" keyboard shortcuts {
		" <C-s> to write file
		nnoremap <C-s> :update<cr>
		inoremap <C-s> <C-o>:update<cr>

		" rebind undo/redo traverse the undo tree instead of the undo stack
		nnoremap  u      g-
		nnoremap  <C-r>  g+
	" }

	" utilities {
		" get output of shell command
		nnoremap  !      :Scratchpad 
	" }

	" open special files
	nnoremap           <leader>B     :tabnew ~/.bashrc<cr>
	nnoremap           <leader>C     :tabnew ~/Dropbox/contacts/contacts-*<cr>
	nnoremap           <leader>J     :tabnew ~/journal/notes.journal<cr>
	nnoremap           <leader>L     :tabnew ~/research/journal/library.bib<cr>
	nnoremap           <leader>R     :tabnew ~/research/journal/2015.journal<cr>
	nnoremap           <leader>T     :tabnew ~/Dropbox/documents/tweets.csv<cr>
	nnoremap           <leader>V     :tabnew ~/.nvim/nvimrc<cr>
	nnoremap           <leader>O     eb"zye:!open $(find ~/Dropbox/library/ -name <C-r>=expand("<cword>")<cr>.pdf)<cr><cr>
	" toggle settings with double leader
	nnoremap           <leader><leader>n     :set number!<cr>:set number?<cr>
	nnoremap           <leader><leader>s     :set spell!<cr>:set spell?<cr>
	nnoremap           <leader><leader>w     :set wrap!<cr>:set wrap?<cr>
	nnoremap           <leader><leader>/     :nohlsearch<cr>
	" editor function shortcuts
	nnoremap           <leader>p     "+p
	nnoremap           <leader>z     1z=
	nnoremap           <leader>@     :<C-f>ilet @=<C-r><C-r>
	nnoremap  <silent> <leader>;     :lcd %:p:h<cr>
	nnoremap           <leader>]     <C-w><C-]><C-w>T
	" custom functions
	nnoremap  <silent> <leader>.     :exe "set foldenable foldlevel=".foldlevel('.')<cr>
" }

" autocommands {
	" filetypes
	autocmd     BufRead,BufNewFile  2*.journal setlocal nobreakindent nofoldenable
	autocmd     BufRead,BufNewFile  *.lisp     setlocal expandtab
	autocmd     BufRead,BufNewFile  *.py       setlocal foldmethod=indent tabstop=4 expandtab
	autocmd     BufRead,BufNewFile  *.tex      setlocal foldmethod=indent spell
	" keep windows equal in size
	autocmd     VimResized          *       normal <c-w>=
	" restore cursor position
	autocmd     BufReadPost         *       if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
	" automatically leave insert mode after 'updatetime' milliseconds, which is 7.5 seconds in insert mode
	autocmd     CursorHoldI         *       stopinsert
	augroup leaveinsert
		autocmd InsertEnter         *       let updaterestore=&updatetime | set updatetime=7500
		autocmd InsertLeave         *       let &updatetime=updaterestore
	augroup END
	" easily cancel the command line window
	autocmd     CmdwinEnter         *       nnoremap <buffer> <C-c> :quit<cr>
	autocmd     CmdwinEnter         *       inoremap <buffer> <C-c> <Esc>:quit<cr>
	" automatically open and close the quickfix window
	augroup quick_fix
		autocmd     QuickFixCmdPost     l*grep* lwindow
		autocmd     WinEnter            *       if winnr('$') == 1 && getbufvar(winbufnr(winnr()), "&buftype") == "quickfix" | q | endif
	augroup END
	" bound scope of search to the original window
	augroup last_search
		autocmd WinLeave            *       let w:search_on = v:hlsearch | let w:last_search = @/
		autocmd WinEnter            *       if exists("w:search_on") && w:search_on | let @/ = w:last_search | else | set nohlsearch | endif
	augroup END
	" disable audio bell in MacVim
	autocmd     GUIEnter            *              set visualbell t_vb=

	" override above settings for specific files
	" automatically fold notes.journal and change directories
	autocmd     BufRead        notes.journal syntax match flag '^.\{2000,\}$' | setlocal breakindent breakindentopt=shift:1 foldenable foldlevel=0 | lcd %:p:h
" }

" commands {
	function! s:TagnewCommand(args)
		tabnew
		execute ":tag " . a:args
	endfunction
	command! -nargs=1 Tagnew :call s:TagnewCommand(<q-args>)

	function! s:ScratchpadCommand(args)
		vnew
		setlocal buftype=nofile nofoldenable noswapfile
		exe "r!" . a:args
		0d
		0
	endfunction
	command! -nargs=* -complete=file Scratchpad :call s:ScratchpadCommand(<q-args>)

	command! -nargs=0 CloseRightTabs :call <SID>CloseRightTabs()
	command! -nargs=1 MoveToRelTab :call <SID>MoveToRelTab(<q-args>)
" }

" plugin settings {
	" ctrlp
	let g:ctrlp_map = '<leader>P'
	let g:ctrlp_prompt_mappings = {
	    \ 'AcceptSelection("e")': ['<c-t>'],
	    \ 'AcceptSelection("t")': ['<cr>', '<2-LeftMouse>'],
	    \ }
	" clever-f
	let g:clever_f_fix_key_direction=1
	let g:clever_f_timeout_ms=5000
	" netrw
	let g:netrw_browse_split = 3
	" python-syntax
	let python_highlight_all = 1
	" vim-fugitive
	nnoremap  <leader>G     :Git 
	nnoremap  <leader>gc    :Gcommit -m "
	nnoremap  <leader>gd    :Gdiff<cr>
	nnoremap  <leader>gs    :Gstatus<cr>
	nnoremap  <leader>gp    :Gpush<cr>
	" vim-makeshift
	nnoremap  <leader><cr>  :MakeshiftBuild \| redraw!<cr>
	let g:makeshift_use_pwd_first = 1
" }

" protect large files from sourcing and other overhead.
" files become read only
if !exists("my_auto_commands_loaded")
	let my_auto_commands_loaded = 1
	" Large files are > 10M
	" Set options:
	" eventignore+=FileType (no syntax highlighting etc.; assumes FileType always on)
	" noswapfile (save copy of file)
	" bufhidden=unload (save memory when other file is viewed)
	" undolevels=-1 (no undo possible)
	let g:LargeFile = 1024 * 1024 * 10
	augroup LargeFile
		autocmd BufReadPre * let f=expand("<afile>") | if getfsize(f) > g:LargeFile | set eventignore+=FileType | setlocal noswapfile bufhidden=unload undolevels=-1 | else | set eventignore-=FileType | endif
	augroup END
endif
